# **Программирование сокетов** #

Для обеспечения сетевых коммуникаций используются сокеты. Сокет это конечная точка сетевых коммуникаций. Каждый использующийся сокет имеет тип и ассоциированный с ним процесс. Сокеты существуют внутри коммуникационных доменов. Домены это абстракции, которые подразумевают конкретную структуру адресации и множество протоколов, которое определяет различные типы сокетов внутри домена. Примерами коммуникационных доменов могут быть: UNIX домен, Internet домен, и т.д.

В Internet домене сокет - это комбинация IP адреса и номера порта, которая однозначно определяет отдельный сетевой процесс во всей глобальной сети Internet. Два сокета, один для хоста-получателя, другой для хоста-отправителя, определяют соединение для протоколов, ориентированных на установление связи, таких, как TCP.

  1. Создание сокета
  1. Привязка к локальным именам
  1. Установление связи
  1. Передача данных
  1. Закрывание сокетов
  1. Пример функции, для установления WWW коннекции

# **Создание сокета** #

Для создания сокета используется системный вызов socket.
s = socket(domain, type, protocol);

Этот вызов основывается на информации о коммуникационном домене и типе сокета. Для использования особенностей Internet, значения параметров должны быть следующими:
communication domain - AF\_INET (Internet протоколы).
type of the socket - SOCK\_STREAM; Этот тип обеспечивает последовательный, надежный, ориентированный на установление двусторонней связи поток байтов.

Выше был упомянут сокет с типом stream. Краткое описание других типов сокетов приведено ниже:
Datagram socket - поддерживает двусторонний поток данных. Не гарантируется, что этот поток будет последовательным, надежным, и что данные не будут дублироваться. Важной характеристикой данного сокета является то, что границы записи данных предопределены.
Raw socket - обеспечивает возможность пользовательского доступа к низлежащим коммуникационным протоколам, поддерживающим сокет-абстракции. Такие сокеты обычно являются датаграм- ориентированными.

Функция socket создает конечную точку для коммуникаций и возвращает файловый дескриптор, ссылающийся на сокет, или -1 в случае ошибки. Данный дескриптор используется в дальнейшем для установления связи.

Для создания сокета типа stream с протоколом TCP, обеспечивающим коммуникационную поддержку, вызов функции socket должен быть следующим:
s = socket(AF\_INET, SOCK\_STREAM, 0);

# **Привязка к локальным именам** #

Сокет создается без имени. Пока с сокетом не будет связано имя, удаленные процессы не имеют возможности ссылаться на него и, следовательно, на данном сокете не может быть получено никаких сообщений. Коммуникационные процессы используют для данных целей ассоциации. В Internet домене ассоциация складывается из локального и удаленного адреса и из локального и удаленного порта. В большинстве доменов ассоциация должна быть уникальной.

В Internet домене связывание сокета и имени может быть весьма сложным, но, к счастью, обычно нет необходимости специально привязывать адрес и номер порта к сокету, так как функции connect и send автоматически свяжут данный сокет с подходящим адресом, если это не было сделано до их вызова.

Для связывания сокета с адресом и номером порта используют системный вызов bind:
bind(s, name, namelen);

Привязываемое имя (name) это строка байт переменной длины, которая интерпретируется поддерживаемым протоколом. Интерпретация может различаться в различных коммуникационных доменах.

# **Установление связи** #

Со стороны клиента связь устанавливается с помощью стандартной функции connect:
error = connect(s, serveraddr, serveraddrlen);

которая инициирует установление связи на сокете, используя дескриптор сокета s и информацию из структуры serveraddr, имеющей тип sockaddr\_in, которая содержит адрес сервера и номер порта на который надо установить связь. Если сокет не был связан с адресом, connect автоматически вызовет системную функцию bind.

Connect возвращает 0, если вызов прошел успешно. Возвращенная величина -1 указывает на то, что в процессе установления связи произошла некая ошибка. В случае успешного вызова функции процесс может работать с дескриптором сокета, используя функции read и write, и закрывать канал используя функцию close.

Со стороны сервера процесс установления связи сложнее. Когда сервер желает предложить один из своих сервисов, он связывает сокет с общеизвестным адресом, ассоциирующимся с данным сервисом, и пассивно слушает этот сокет. Для этих целей используется системный вызов listen:
error = listen(s, qlength);

где s это дескриптор сокета, а qlength это максимальное количество запросов на установление связи, которые могут стоять в очереди, ожидая обработки сервером; это количество может быть ограничено особенностями системы.

Когда сервер получает запрос от клиента и принимает решение об установлении связи, он создает новый сокет и связывает его с ассоциацией, эквивалентной 'слушающему сокету'. Для Internet домена это означает тот же самый номер порта. Для этой цели используется системный вызов accept:
newsock = accept(s, clientaddr, clientaddrlen);

Сокет, ассоциированный клиентом, и сокет, который был возвращен функцией accept, используются для установления связи между сервером и клиентом.

# **Передача данных** #

Когда связь установлена, с помощью различных функций может начаться процесс передачи данных. При наличии связи, пользователь может посылать и получать сообщения с помощью функций read и write:
write(s, buf, sizeof(buf)); read(s, buf, sizeof(buf));

Вызовы send и recv практически идентичны read и write, за исключением того, что добавляется аргумент флагов.
send(s, buf, sizeof(buf), flags); recv(s, buf, sizeof(buf), flags);

Могут быть указаны один или более флагов с помощью ненулевых значений, таких, как следующие:
MSG\_OOB - Посылать/получать данные, характерные для сокетов типа stream.
MSG\_PEEK - Просматривать данные без чтения. когда указывается в recv, любые присутствующие данные возвращаются пользователю, но сами данные остаются как "непрочитанные". Следующий read или recv вызванный на данном сокете вернет прочитанные в прошлый раз данные.
MSG\_DONTROUTE - посылать данные без маршрутизации пакетов. (Используется только процессами, управляющими таблицами маршрутизации.)

# **Закрывание сокетов** #

Когда взаимодействующие модули решают прекратить передачу данных и закрыть сеанс связи, они обмениваются трехсторонним рукопожатием с сегментами, содержащими установленный бит "От отправителя больше нет данных" (этот бит еще называется FIN бит).

Если сокет больше не используется, процесс может закрыть его с помощью функции close, вызвав ее с соответствующим дескриптором сокета:
close(s);

Если данные были ассоциированы с сокетом, обещающим доставку (сокет типа stream), система будет пытаться осуществить передачу этих данных. Тем не менее, по истечении довольно таки длительного промежутка времени, если данные все еще не доставлены, они будут отброшены. Если пользовательский процесс желает прекратить любую передачу данных, он может сделать это с помощью вызова shutdown на данном сокете для его закрытия. Вызов shutdown вызывает "моментальное" отбрасывание всех стоящих в очереди данных. Формат вызова следующий:
shutdown(s, how);

где how имеет одно из следующих значений:
0 - если пользователь больше не желает читать данные
1 - если данные больше не будут посылаться
2 - если данные не будут ни посылаться ни получаться

# **Пример функции, для установления WWW коннекции** #

/

> MakeConnection

> Function allocates a socket and estabishes a connection
> with remote host. Default port number 80.

> Input : WWW server name (with port number, if it is not 80)
> Output : file descriptor on success
> -1 on error

**/
int MakeConnection(unsigned char** ServerName){
> int s;
> struct sockaddr\_in ssin;
> struct hostent**hp;
> int PortNum;
> unsigned char strHlp[STRNGLEN](STRNGLEN.md),**pch;

> /**use default port number - 80 or specific number from the
> server name**/
> strcpy(strHlp,ServerName);
> pch = strchr(strHlp,':');
> if(pch==NULL){
> PortNum = 80;
> }else{
> pch[0](0.md) = '';
> pch++;
> PortNum = atoi(pch);
> if(PortNum==0){
> PortNum = 80;
> }
> }

> /**get host by name - resolve host name into IP address**/
> if( (hp=gethostbyname(strHlp)) == NULL )
> {
> return -1;
> }

> bzero(&ssin, sizeof(ssin));
> bcopy(hp->h\_addr, &ssin.sin\_addr, hp->h\_length);
> ssin.sin\_family = hp->h\_addrtype;
> ssin.sin\_port = htons(PortNum);

> /**allocate a socket**/
> if((s=socket(AF\_INET, SOCK\_STREAM, 0))==-1)
> {
> return -1;
> }

> /**make a connection**/
> if(connect(s, &ssin, sizeof(ssin), 0)==-1){

> return -1;
> }

> return s; /**socket descriptor**/
}